#!/usr/bin/env bash

usage='usage: tmux-run <session-name> \          # session name required unless --npm set; all other args optional
  [-h|--help] \
  [-n|--npm] \                            # if set, prefix each command with "npm run" for package.json scripts
  [[-l|--layout=]{integer}] \             # [default: generated for # of cmds] each digit represents number of panes in column
  [[-o|--orientation=]ttb|ltr] \          # [default: ttb (top-to-bottom)] transpose layout if orientation=ltr (left-to-right)
  [[-e|--exists=]replace|attach|error] \  # [default: replace] replace, attach, or error when session already exists
  [--extra="tmux cmd A ; tmux cmd B"] \   # extra tmux commands to be executed after window and panes are created
  ["shell command 1"] \                   # shell commands that will be executed in each pane
  ["shell command 2"] \
  ...
  ["shell command N"]                     # number of shell commands N must not exceed sum of layout
'

# parse args into vars:
argsession=""      # required - session name
arglayout=""       # optional - string of digits defining a custom layout
                #            each digit represents num of panes in each column
argorientation=""  # optional - ttb (top-to-bottom, default) or ltr (left-to-right)
                #            if ltr, transpose layout into rows instead of columns
argexists=""       # optional - attach/replace/error exists when session exists
argextra=""        # optional - extra commands to be executed after layout commands
                #            e.g. extra="set-window-option remain-on-exit off"
argnpm=""          # optional - if set, prefix each command with "npm run" for package.json scripts
argcmds=""         # optional - list of commands to be executed in resulting panes

# tmux command that will be constructed and executed:
tmuxcmd=""

function processargs () {
  # -h|--help
  if [[ "$1" =~ ^(--help|-h)$ ]]; then
    echo "${usage}"
    exit 0
  fi

  # 1st arg: session name
  argsession="$1"
  shift

  # 2nd arg: npm
  if [[ "${argsession}" =~ ^(--npm|-n)$ ]]; then
    # allow ommission of session name if --npm is set
    argnpm="true"
    argsession="$npm_package_name"
  elif [[ "$1" =~ ^(--npm|-n)$ ]]; then
    argnpm="true"
    shift
  fi

  # 3rd arg: layout (string of digits)
  if [[ "$1" =~ ^--layout= ]] || [[ "$1" =~ ^(--layout|-l)?=?[][0-9]+$ ]]; then
    arglayout="$1"
    shift
    arglayout="${arglayout#--layout}"  # remove prefix (if necessary)
    arglayout="${arglayout#-l}"
    arglayout="${arglayout#=}"
    # if layout invalid, exit with error
    if ! [[ "${arglayout}" =~ ^[][0-9]+$ ]]; then
      echo "invalid input: --layout=${arglayout} must contain only numeric characters and brackets"
      echo "${usage}"
      exit 1
    fi
    # if layout contains zero, exit with error
    if [[ "${arglayout}" =~ 0 ]]; then
      echo "invalid input: --layout=${arglayout} column cannot be set to zero"
      echo "${usage}"
      exit 1
    fi
  fi

  # 4th arg: orientation [ltr|ttb] default:ttb
  if [[ "$1" =~ ^--orientation= ]] || [[ "$1" =~ ^(--orientation|-o)?=?(ttb|ltr)$ ]]; then
    argorientation="$1"
    shift
    argorientation="${argorientation#--orientation}"  # remove prefix (if necessary)
    argorientation="${argorientation#-o}"
    argorientation="${argorientation#=}"
    if ! [[ "${argorientation}" =~ ^(ttb|ltr)$ ]]; then
      echo "invalid input: --orientation=${argorientation} must be [ttb|ltr]"
      echo "${usage}"
      exit 1
    fi
  else
    # default
    argorientation="ttb"
  fi

  # 5th arg: exists [replace|attach|error] default:replace
  if [[ "$1" =~ ^--exists= ]] || [[ "$1" =~ ^(--exists|-e)?=?(replace|attach|error)$ ]]; then
    argexists="$1"
    shift
    argexists="${argexists#--exists}"  # remove prefix (if necessary)
    argexists="${argexists#-e}"
    argexists="${argexists#=}"
    if ! [[ "${argexists}" =~ ^(replace|attach|error)$ ]]; then
      echo "invalid input: --exists=${argexists} must be [replace|attach|error]"
      echo "${usage}"
      exit 1
    fi
  else
    # default
    argexists="replace"
  fi

  # 6th arg: extra
  if [[ "$1" =~ ^--extra=? ]]; then
    argextra="$1"
    shift
    argextra="${argextra#--extra}"  # remove prefix
    argextra="${argextra#=}"
  fi

  argcmds=( "$@" )
}

function generatelayout () {
  # generate a default layout based on specified size:
  # size:1 -> layout:"1"
  # size:2 -> layout:"11"
  # size:3 -> layout:"12"
  # size:4 -> layout:"22"
  # size:5 -> layout:"122"
  # size:6 -> layout:"222"
  # size:7 -> layout:"1222"
  # size:8 -> layout:"233"
  # ...

  # params:
  # $1 size [integer] size of layout

  # modifies:
  # ${arglayout}

  local size

  size="$1"
  shift

  local root
  local quot
  local rmdr

  root=$( bc <<< "scale=0; sqrt( ${size} + 1 )" )
  root=${root%.*}  # floor
  quot=$(( ${size} / ${root} ))
  quot=${quot%.*}  # floor
  rmdr=$(( ${size} % ${root} ))
  arglayout=$( printf "%0.s${root}" $( seq 1 "${quot}" ) )
  if (( "${rmdr}" > 0 )); then
    arglayout="${rmdr}${arglayout}"
  fi
}

function validatelayout () {
  # ensure layout is large enough to contain specified size

  # params:
  # $1 minsize [integer] minimum size of layout

  local minsize

  minsize="$1"
  shift

  local idx
  local char
  local layoutsizesum

  layoutsizesum=0
  for (( idx = 0; "${idx}" < "${#arglayout}"; idx++ )); do
    char="${arglayout:${idx}:1}"
    if [[ "${char}" =~ [0-9] ]]; then
      (( layoutsizesum+="${char}" ))
    fi
  done

  # if size exceeds sum of layout string digits, exit with error
  if (( "${minsize}" > "${layoutsizesum}" )); then
    echo "invalid input: --layout=${arglayout} is too small for number of commands provided"
    echo "${usage}"
    exit 1
  fi
}

function selectpane () {
  # construct a set of tmux select-pane commands according to params

  # params:
  # $1 direction [string "v"|"h"]    direction to split current pane (vertical or horizontal)
  # $2 flags     [string]            pair of flags that will be used based on direction
  # $3 repeat    [integer default=1] number of times the select-pane operation will be repeated

  # modifies:
  # ${tmuxcmd}

  local direction
  local flags
  local repeat

  direction="$1"
  shift
  flags="$1"
  shift
  repeat="$1"
  shift

  local idx
  local flag

  if [[ -z "${repeat}" ]]; then
    repeat=1
  fi

  [[ "${direction}" == "v" ]] && flag="${flags:0:1}" || flag="${flags:1:1}"

  for (( idx = 0; "${idx}" < "${repeat}"; idx++ )); do
    tmuxcmd+=" \\; select-pane -${flag}"
  done
}

function split1d () {
  # construct a set of tmux split-window and select-pane commands that will split
  # the current pane into `numpanes` equally-sized separate panes

  # params:
  # $1 direction [string "v"|"h"] direction to split current pane (vertical or horizontal)
  # $2 numpanes  [integer]        number of panes to split current pane into
  # $@ cmds      [array<string>]  list of commands to be executed in resulting panes

  # modifies:
  # ${tmuxcmd}

  local direction
  local numpanes
  local cmds

  direction="$1"
  shift
  numpanes="$1"
  shift
  cmds=( "$@" )

  local percentage
  local half
  local flag

  if (( "${numpanes}" >= 2 )); then
    if (( "${numpanes}" == 2 )); then
      tmuxcmd+=" \\; split-window -${direction} \"${cmds[1]}\""
    elif (( "${numpanes}" % 2 > 0 )); then
      # percentage = round(100 - (100 / $numpanes))
      percentage=$(( 100 - ( ( 100 + ( ${numpanes} / 2 ) ) / ${numpanes} ) ))
      tmuxcmd+=" \\; split-window -${direction} -p${percentage} \"${cmds[1]}\""
      split1d "${direction}" "$(( ${numpanes} - 1 ))" "${cmds[@]:1}"
    else
      half=$(( ${numpanes} / 2 ))
      tmuxcmd+=" \\; split-window -$direction -d \"${cmds[${half}]}\""
      split1d "${direction}" "${half}" "${cmds[@]:0:${half}}"  # 1st half of cmds
      selectpane "${direction}" "DR"
      split1d "${direction}" "${half}" "${cmds[@]:${half}}"    # 2nd half of cmds
    fi
  fi
}

function split2d () {
  # construct a set of tmux split-window and select-pane commands that will split
  # the current pane according to layout

  # params:
  # $1 direction [string "v"|"h"] direction to split current pane (vertical or horizontal)
  # $2 layout    [string]         number of panes to split current pane into
  # $@ cmds      [array<string>]  list of commands to be executed in resulting panes

  # modifies:
  # ${tmuxcmd}

  local direction
  local layout
  local cmds

  direction="$1"
  shift
  layout="$1"
  shift
  cmds=( "$@" )

  local idx
  local char
  local depth
  local flag

  local sublayouts
  local numsublayouts
  local sublayoutsizes
  local sublayoutsize

  local initialcmds
  local initialcmdidx
  local subcmds

  # expand layout string into two arrays: sublayouts & sublayoutsizes
  # e.g. "12[34[5]]6" -> ["1", "11", "34[5]", "111111"]  # sublayouts
  #                   -> [ 1,   2,    12,      6      ]  # sublayoutsizes
  depth=0
  sublayouts=()
  sublayoutsizes=()
  for (( idx = 0; "${idx}" < "${#layout}"; idx++ )); do
    char="${layout:${idx}:1}"

    if [[ "${char}" == "]" ]]; then
      (( depth-=1 ))
    fi

    if (( "${depth}" > 0 )); then
      sublayouts[$(( ${#sublayouts[@]} - 1 ))]+="${char}"

      if [[ "${char}" =~ [0-9] ]]; then
        (( sublayoutsizes[$(( ${#sublayoutsizes[@]} - 1 ))]+=${char} ))
      fi
    fi

    if [[ "${char}" == "[" ]]; then
      if (( "${depth}" == 0 )); then
        sublayouts+=( "" )
        sublayoutsizes+=( 0 )
      fi
      (( depth+=1 ))
    fi

    if [[ "${char}" =~ [0-9] ]] && (( "${depth}" == 0 )); then
      sublayoutsizes+=( "${char}" )
      sublayouts+=( $( printf "%0.s1" $( seq 1 "${char}" ) ) )
    fi
  done

  numsublayouts="${#sublayouts[@]}"

  # construct initial set of panes
  initialcmds=()
  initialcmdidx=0
  for (( i = 0; i < "${numsublayouts}"; i++ )); do
    sublayoutsize="${sublayoutsizes[${i}]}"
    initialcmds+=( "${cmds[${initialcmdidx}]}" )
    (( initialcmdidx+="${sublayoutsize}" ))
  done
  split1d "${direction}" "${numsublayouts}" "${initialcmds[@]}"

  # select first pane
  selectpane "${direction}" "UL" $(( ${numsublayouts} - 1 ))

  # split each pane as specified by layout
  initialcmdidx=0
  for (( idx = 0; "${idx}" < "${numsublayouts}"; idx++ )); do
    sublayout="${sublayouts[${idx}]}"
    sublayoutsize="${sublayoutsizes[${idx}]}"

    if (( ${idx} > 0 )); then
      selectpane "${direction}" "DR"
    fi

    [[ "${direction}" == "v" ]] && flag="h" || flag="v"
    subcmds=( "${cmds[@]:${initialcmdidx}:${sublayoutsize}}" )

    # if layout contains only columns of 1, we can split 1-dimensional
    if [[ "${sublayout}" =~ ^1+$ ]]; then
      split1d "${flag}" "${sublayoutsize}" "${subcmds[@]}"
    else
      split2d "${flag}" "${sublayout}" "${subcmds[@]}"
    fi

    (( initialcmdidx+="${sublayoutsize}" ))
  done
}

function main () {
  # construct and execute a tmux command that runs a set of commands inside a layout

  # params:
  # $@ args [array<any>] arguments passed to script

  # references:
  # ${argsession}
  # ${arglayout}
  # ${argorientation}
  # ${argexists}
  # ${argextra}
  # ${argcmds}

  # modifies:
  # ${tmuxcmd}

  local idx
  local flag
  local numcmds

  processargs "$@"

  numcmds="${#argcmds[@]}"

  # if npm option is set, prefix commands "npm run ..."
  if [[ -n "${argnpm}" ]]; then
    for (( idx = 0; "${idx}" < "${#argcmds[@]}"; idx++ )); do
      argcmds[idx]="npm run ${argcmds[idx]}"
      #argcmds["${idx}"]="echo \"${argcmds[${idx}]}\" && sleep 1000"
    done
  fi

  # begin to construct tmux command
  tmuxcmd+="tmux new-session -s \"${argsession}\" \"${argcmds[0]}\""

  # if layout is not specified, generate a default
  if [[ -z "${arglayout}" ]]; then
    generatelayout "${numcmds}"
  fi

  # ensure layout is large enough to contain commands provided
  validatelayout "${numcmds}"

  # append layout commands onto tmuxcmd
  [[ "${argorientation}" == "ltr" ]] && flag="v" || flag="h"
  split2d "${flag}" "${arglayout}" "${argcmds[@]}"

  # append extra tmux commands as specified by `extra` arg onto tmuxcmd
  tmuxcmd+=" \\; set-window-option remain-on-exit on"
  tmuxcmd+=" \\; ${argextra//;/\\\\;}"  # escape semicolons - replace ";" with "\\;"

  # either attach to an existing session or kill it based on specified behavior
  if [[ "${argexists}" == "attach" ]]; then
    tmux has-session -t "${argsession}" 2>/dev/null
    if [ "$?" == 0 ]; then  # if session exists, re-attach
      tmux attach-session -t "${argsession}"
      exit 0
    fi
  elif [[ "${argexists}" == "replace" ]]; then
    tmux kill-session -t "${argsession}" || true  # ignore 'session does not exist' error
  fi

  # execute constructed tmux command
  bash -c "${tmuxcmd}"
  #echo "${tmuxcmd}"
}

main "$@"
