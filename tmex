#!/usr/bin/env bash

# tmex 1.0.10

# sanity - exit on any error; no unbound variables
set -euo pipefail

function processargs () {
  local args argidx arg flags idx char

  args=( "${@-}" )
  argidx=0

  # session name
  argsession="${args[argidx]-}"

  # check if we're skipping session name, if it matches another arg type
  if [[ "${argsession}" =~ ^--(detached|help|kill|npm|print|reattach|shellless|transpose|version)$ ]]; then
    argsession=""
  elif [[ "${argsession}" =~ ^--(focus|layout) ]]; then
    argsession=""
  elif [[ "${argsession}" =~ ^-[dfhklnprstv]+ ]]; then
    argsession=""
  else
    (( argidx++ )) || true
  fi

  while true; do
    arg="${args[argidx]-}"
    if [[ "${arg}" =~ ^(-([dhknprstv]*)l|--layout) ]]; then
      (( argidx++ )) || true
      if [[ "${arg}" != '--layout' ]]; then
        arg="${arg/-${BASH_REMATCH[2]}/-}"
      fi
      if [[ "${arg}" == "-l" || "${arg}" == '--layout' ]]; then
        arg="${args[argidx]-}"
        (( argidx++ )) || true
      fi
      arglayout="${arg}"
      arglayout="${arglayout#--layout}"  # remove possible prefixes (if necessary)
      arglayout="${arglayout#-l}"
      arglayout="${arglayout#=}"
      flags="${BASH_REMATCH[2]}"

    elif [[ "${arg}" =~ ^(-([dhknprstv]*)f|--focus) ]]; then
      (( argidx++ )) || true
      if [[ "${arg}" != '--focus' ]]; then
        arg="${arg/-${BASH_REMATCH[2]}/-}"
      fi
      if [[ "${arg}" == "-f" || "${arg}" == "--focus" ]]; then
        arg="${args[argidx]-}"
        (( argidx++ )) || true
      fi
      argfocus="${arg}"
      argfocus="${argfocus#--focus}"  # remove possible prefixes (if necessary)
      argfocus="${argfocus#-f}"
      argfocus="${argfocus#=}"
      flags="${BASH_REMATCH[2]}"

      if ! [[ "${argfocus}" =~ ^-?[0-9]+$ ]]; then
        echo ""
        echo "Invalid input: --focus (-f) arg value must be an integer"
        echo ""
        echo "${usage}"
        exit 1
      fi

    elif [[ "${arg}" =~ ^--(detached|help|kill|npm|print|reattach|shellless|transpose|version)$ ]]; then
      (( argidx++ )) || true
      arg="${arg#--}"  # remove "--" prefix
      case "${arg}" in
        'detached')  argdetached=TRUE;;
        'help')      arghelp=TRUE;;
        'npm')       argnpm=TRUE;;
        'print')     argprint=TRUE;;
        'reattach')  argreattach=TRUE;;
        'shellless') argshellless=TRUE;;
        'transpose') argtranspose=TRUE;;
        'kill')      argkill=TRUE;;
        'version')   argversion=TRUE;;
      esac
    elif [[ "${arg}" =~ ^-[dhknprstv]+$ ]]; then
      (( argidx++ )) || true
      arg="${arg#-}"  # remove "-" prefix
      flags="${arg}"
    else
      break
    fi

    if [[ -n "${flags}" ]]; then
      for (( idx = 0; idx < ${#flags}; idx++ )); do
        char="${flags:idx:1}"
        case "${char}" in
          'd') argdetached=TRUE;;
          'h') arghelp=TRUE;;
          'n') argnpm=TRUE;;
          'p') argprint=TRUE;;
          'r') argreattach=TRUE;;
          's') argshellless=TRUE;;
          't') argtranspose=TRUE;;
          'k') argkill=TRUE;;
          'v') argversion=TRUE;;
        esac
      done
      flags=""
    fi
  done

  # if next arg is a valid layout, use it as layout instead of shell command
  arg="${args[argidx]-}"
  if [[ -z "${arglayout}" && "${arg}" =~ ^[][}{0-9,+-]+$ ]]; then
    (( argidx++ )) || true
    arglayout="${arg}"
  fi

  # use rest of args as shell commands
  argcmds=( "${args[@]:argidx}" )

  # allow omission of session name if --npm is set
  if [[ -z "${argsession}" && "${argnpm}" == TRUE ]]; then
    argsession="${npm_package_name-}"  # default to avoid 'unbound local variable' issues

    # if env var is undefined we're probably running manually instead of from an npm script;
    # try and pull package name from npm env manually
    if [[ -z "${argsession}" ]]; then
      argsession="$( cut -d "=" -f 2 <<< "$( npm run env 2> /dev/null | grep 'npm_package_name' )" )"
    fi
  fi

  # allow omission of session name if --kill is set
  if [[ -z "${argsession}" && "${argkill}" == TRUE ]]; then
    if (( ${#args[@]} == 2 )) && ! [[ "${args[1]}" =~ ^- ]]; then
      # if there's only one other arg and it doesn't start with "-" or "--",
      # treat this arg as the session name to kill:
      argsession="${args[1]}"
      argcmds=()  # since arg is now session name, remove from argcmds
    elif [[ -n "${TMUX_PANE-}" ]]; then
      # otherwise, if we're currently in a tmux session, kill that session:
      argsession="${TMUX_PANE-}"
    fi
  fi

  # warn and exit of --kill was specified but other arguments were provided
  if [[ "${argkill}" == TRUE ]]; then
    if (( ${#argcmds[@]} > 0 )) || [[ "${argdetached}" == TRUE || "${argnpm}" == TRUE || "${argreattach}" == TRUE || "${argshellless}" == TRUE || "${argtranspose}" == TRUE ]]; then
      echo "You specified --kill (-k) but there are extra args."
      echo "Run command again without extra args if you want to kill the session."
      exit 1
    fi
  fi

  if [[ -z "${argsession}" && "${arghelp}" == FALSE && "${argversion}" == FALSE ]]; then
    echo ""
    echo "Invalid input: session name required (call 'tmex <session-name> <options> <commands>')"
    echo ""
    echo "${usage}"
    exit 1
  fi

  # tmux rewrites "."->"_", ":"->"_", "\"->"\\" when setting session names
  # by making these replacements, we can allow tmex to reattach/kill sessions
  # as expected later, even if these chars are present in the given session name:
  argsession="${argsession//./_}"
  argsession="${argsession//:/_}"
  argsession="${argsession//\\/\\\\}"
}

function generatelayout () {
  local size root quot rmdr

  # Generate a default layout based on specified size:
  #   size:1 -> layout:"1"
  #   size:2 -> layout:"11"
  #   size:3 -> layout:"12"
  #   size:4 -> layout:"22"
  #   size:5 -> layout:"122"
  #   size:6 -> layout:"222"
  #   size:7 -> layout:"1222"
  #   size:8 -> layout:"233"
  #   ...
  # Params:
  #   $1 size [integer] size of layout
  # Modifies external:
  #   ${arglayout}

  size="$1"

  if (( size == 0 )); then
    arglayout="1"
  else
    root=$( bc <<< "scale=0; sqrt( ${size} + 1 )" )
    root=${root%.*}  # floor
    quot=$(( size / root ))
    quot=${quot%.*}  # floor
    rmdr=$(( size % root ))
    arglayout=$( printf "%0.s${root}" $( seq 1 "${quot}" ) )
    if (( rmdr > 0 )); then
      arglayout="${rmdr}${arglayout}"
    fi
  fi
}

function validatelayout () {
  local minsize idx char nextchar layoutsizesum sizebracketsopen multidigitvalue

  # Ensure layout is valid and large enough to contain specified size.
  # Params:
  #   $1 minsize [integer] minimum size of layout

  minsize="$1"

  # if layout contains characters other than 0-9, [, ], {, }, or comma, exit with error
  if ! [[ "${arglayout}" =~ ^[][}{0-9,]+$ ]]; then
    echo ""
    echo "Invalid input: --layout=${arglayoutoriginal} must contain only numeric characters and [ ] { } brackets"
    echo ""
    echo "${usage}"
    exit 1
  fi

  # if layout contains non-numeric non-comma characters within { } brackets, exit with error
  if [[ "${arglayout}" =~ {[^}{]*[^0-9,][^}{]*} ]]; then
    echo ""
    echo "Invalid input: --layout=${arglayoutoriginal} cannot include non-numeric characters within { } brackets"
    echo ""
    echo "${usage}"
    exit 1
  fi

  # if layout contains empty { } brackets, exit with error
  if [[ "${arglayout}" == *'{}'* ]]; then
    echo ""
    echo "Invalid input: --layout=${arglayoutoriginal} cannot include empty { } brackets"
    echo ""
    echo "${usage}"
    exit 1
  fi

  # if layout contains non-numeric non-plus characters preceeding '+' exit with error
  if [[ "${arglayout}" =~ [^0-9+]\+ ]]; then
    echo ""
    echo "Invalid input: --layout=${arglayoutoriginal} cannot include '+' immediately preceeded by non-numeric character"
    echo ""
    echo "${usage}"
    exit 1
  fi

  # if layout contains non-numeric non-minus characters preceeding '-' exit with error
  if [[ "${arglayout}" =~ [^0-9-]\- ]]; then
    echo ""
    echo "Invalid input: --layout=${arglayoutoriginal} cannot include '+' immediately preceeded by non-numeric character"
    echo ""
    echo "${usage}"
    exit 1
  fi

  # if layout contains multiple groups of '+' or '-' exit with error
  if [[ "${arglayout}" =~ [+-]+[^+-]+[+-]+ ]]; then
    echo ""
    echo "Invalid input: --layout=${arglayoutoriginal} cannot multiple groups of '+' and '-' characters"
    echo ""
    echo "${usage}"
    exit 1
  fi

  layoutsizesum=0
  sizebracketsopen=FALSE
  multidigitvalue='-1'
  if [[ "${arglayout}" =~ ^[0-9]+, ]]; then
    multidigitvalue=''
  fi
  for (( idx = 0; idx < ${#arglayout}; idx++ )); do
    char="${arglayout:${idx}:1}"
    nextchar="${layout:$(( idx + 1 )):1}"

    if [[ "${char}" == "," ]]; then
      if [[ "${nextchar}" =~ ^[0-9]$ ]]; then
        multidigitvalue=''
      fi
      continue
    elif [[ "${multidigitvalue}" != '-1' && "${char}" =~ ^[0-9]$ ]]; then
      multidigitvalue+="${char}"
      if [[ "${nextchar}" =~ ^[0-9]$ ]]; then
        continue
      else
        char="${multidigitvalue}"
        multidigitvalue='-1'
      fi
    else
      multidigitvalue='-1'
    fi

    if [[ "${char}" == '0' ]]; then
      continue
    elif [[ "${char}" == '{' ]]; then
      sizebracketsopen=TRUE
    elif [[ "${char}" == '}' ]]; then
      sizebracketsopen=FALSE
    elif [[ "${sizebracketsopen}" == FALSE && "${char}" =~ ^[0-9]+$ ]]; then
      (( layoutsizesum += char )) || true
    fi
  done

  # if size exceeds sum of layout string digits, exit with error
  if (( minsize > layoutsizesum )); then
    echo ""
    echo "Invalid input: --layout=${arglayoutoriginal} is too small for number of commands provided"
    echo ""
    echo "${usage}"
    exit 1
  fi
}

function selectpane () {
  local direction flags repeat idx flag

  # Construct tmux select-pane args according to params.
  # Params:
  #   $1 direction [string "v"|"h"] direction to select in (vertical or horizontal)
  #   $2 flags     [string]         flags that will be used based on direction
  #   $3 repeat    [integer]        repeat select-pane operation N times
  # Modifies external:
  #   ${tmuxargs}

  direction="$1"
  flags="$2"
  repeat="$3"

  [[ "${direction}" == 'v' ]] && flag="${flags:0:1}" || flag="${flags:1:1}"

  for (( idx = 0; idx < repeat; idx++ )); do
    tmuxargs+=( ';' 'select-pane' "-${flag}" )
  done
}

function executecmd () {
  local cmd

  # Construct tmux args to execute a given command.
  # Params:
  #   $1 cmd [string] shell command that will be executed
  # References external:
  #   ${argshellless}
  # Modifies external:
  #   ${tmuxargs}

  cmd="$1"

  if [[ -n "${cmd}" ]]; then
    # if running in "shell-less" mode, execute command directly;
    # otherwise use send-keys to execute command within default shell
    if [[ "${argshellless}" == TRUE ]]; then
      tmuxargs+=( "${cmd}" )
    else
      tmuxargs+=( ";" "send-keys" "${cmd}" "Enter" )
    fi
  fi

}

function split1d () {
  local direction numpanes sizing cmds cmd idx char flag
  local half sizesum sizearr percentage pctprefix pctsuffix multidigitvalue

  # Construct tmux split-window and select-pane args that will split
  # the current pane into `numpanes` equally-sized separate panes.
  # Params:
  #   $1 direction [string "v"|"h"] direction to split pane (vertical or horizontal)
  #   $2 numpanes  [integer]        number of panes to split current pane into
  #   $3 sizing    [string]         relative sizing of panes
  #   $@ cmds      [array<string>]  list of commands to be executed in resulting panes
  # References external:
  #   ${argshellless}
  # Modifies external:
  #   ${tmuxargs}

  direction="$1"
  numpanes="$2"
  sizing="$3"

  shift 3; cmds=( "${@-}" )

  # support for percentage values under `split-pane -l<value>%` was added in tmux 3.1
  # and `split-pane -p<value>` was deprecated (fully removed in tmux 3.4)
  # see https://github.com/tmux/tmux/blob/master/CHANGES#L663-L665 for details
  if [[ -z "${tmuxversion}" ]] || (( $( bc -l <<< "${tmuxversion} < 3.1" ) )); then
    pctprefix="-p"
    pctsuffix=""
  else
    pctprefix="-l"
    pctsuffix="%"
  fi

  # convert sizing string to sizearr:
  # sizing: "1,2,3"  -> [1, 2, 3]
  # sizing: ""       -> []
  # sizing: "2,3"    -> [2, 3]
  # sizing: "12,13"  -> [12, 13]
  # NOTE: leading/trailing commas on these strings are acceptable
  sizesum="${numpanes}"
  sizearr=()
  multidigitvalue=''
  for (( idx = 0; idx <= ${#sizing}; idx++ )); do
    char="${sizing:idx:1}"
    if [[ "${char}" =~ ^[0-9]$ ]]; then
      multidigitvalue+="${char}"
    elif [[ -n "${multidigitvalue}" ]]; then
      sizearr+=( "${multidigitvalue}" )
      (( sizesum += ( multidigitvalue - 1 ) )) || true
      multidigitvalue=''
    fi
  done

  # if more than 2 panes and numpanes is even, split down the middle
  if (( numpanes > 2 && numpanes % 2 == 0 )); then

    # calculate half of size array
    half=$(( numpanes / 2 ))
    halfsizesum=0

    for (( idx = 0; idx < half; idx++ )); do
      (( halfsizesum += ${sizearr[idx]:-1} )) || true
    done

    # percentage = 100 - round((halfsizesum * 100) / sizesum)
    percentage=$(( ( halfsizesum * 100 * 1000 ) / sizesum ))
    percentage=$(( ( percentage + 500 ) / 1000 ))  # round
    percentage=$(( 100 - percentage ))  # invert

    # split pane down the middle (adjusted according to size array)
    tmuxargs+=( ";" "split-window" "-${direction}" "${pctprefix}${percentage}${pctsuffix}" )
    executecmd "${cmds[${half}]-}"
    selectpane "${direction}" "UL" 1

    # keep splitting - 1st half of panes, then select pane at middle, then 2nd half
    split1d "${direction}" "${half}" "$( IFS=','; echo "${sizearr[@]:0:half}" )" "${cmds[@]:0:half}"
    selectpane "${direction}" "DR" 1
    split1d "${direction}" "${half}" "$( IFS=','; echo "${sizearr[@]:half}" )" "${cmds[@]:half}"

  # if only 2 panes or numpanes is odd, split off first pane
  elif (( numpanes >= 2 )); then

    # percentage = 100 - round((sizearr[0] * 100) / sizesum)
    percentage=$(( ( ${sizearr[0]:-1} * 100 * 1000 ) / sizesum ))
    percentage=$(( ( percentage + 500 ) / 1000 ))  # round
    percentage=$(( 100 - percentage ))  # invert
    # below calculation would provide float percentages (2 decimal places) which
    # would result in more accurate pane proportions, but tmux doesn't support
    # decimal percentages at this time
    # percentage="$(
    #   bc -l <<< "100 - ${sizearr[0]:-1} * 100 / ${sizesum}" | xargs printf %.2f
    # )"

    # split off first pane (adjusted according to size array)
    tmuxargs+=( ";" "split-window" "-${direction}" "${pctprefix}${percentage}${pctsuffix}" )
    executecmd "${cmds[1]-}"

    # if more than 2 panes, keep splitting
    if (( numpanes > 2 && numpanes % 2 > 0 )); then
      split1d "${direction}" "$(( numpanes - 1 ))" "$( IFS=','; echo "${sizearr[@]:1}" )" "${cmds[@]:1}"
    fi
  fi
}

function split2d () {
  local direction layout cmds idx char nextchar depth flag
  local sublayouts numsublayouts
  local sublayoutpanecounts sublayoutpanecount sublayoutsizings
  local initialcmds initialcmdidx subcmds sizebracketsopen multidigitvalue

  # Construct a set of tmux split-window and select-pane commands that will split
  # the current pane according to layout.
  # Params:
  #   $1 direction [string "v"|"h"] direction to split pane (vertical or horizontal)
  #   $2 layout    [string]         number of panes to split current pane into
  #   $3 sizing    [string]         relative sizing of panes
  #   $@ cmds      [array<string>]  list of commands to be executed in resulting panes
  # Modifies external:
  #   ${tmuxargs}
  #   ${centerpaneidx}

  direction="$1"
  layout="$2"
  sizing="$3"

  shift 3; cmds=( "${@-}" )

  # expand layout string into three arrays:
  # e.g. "12{31}[3[45]{21}]{12}6"
  # -> ["1", "11",   "3[45]{21}", "111111"]  # sublayouts
  # -> [ 1,   2,      12,          6      ]  # sublayoutpanecounts
  # -> ["",  "3,1,", "1,2,",      ""      ]  # sublayoutsizings
  depth=0
  sublayouts=()
  sublayoutpanecounts=()
  sublayoutsizings=()
  sizebracketsopen=FALSE
  multidigitvalue='-1'
  if [[ "${layout}" =~ ^[0-9]+, ]]; then
    multidigitvalue=''
  fi
  for (( idx = 0; idx < ${#layout}; idx++ )); do
    char="${layout:${idx}:1}"
    nextchar="${layout:$(( idx + 1 )):1}"

    if [[ "${char}" == "," ]]; then
      if [[ "${nextchar}" =~ ^[0-9]$ ]]; then
        multidigitvalue=''
      fi
      continue
    elif [[ "${multidigitvalue}" != '-1' && "${char}" =~ ^[0-9]$ ]]; then
      multidigitvalue+="${char}"
      if [[ "${nextchar}" =~ ^[0-9]$ ]]; then
        continue
      else
        char="${multidigitvalue}"
        multidigitvalue='-1'
      fi
    else
      multidigitvalue='-1'
    fi

    if [[ "${char}" == '0' ]]; then
      continue
    elif [[ "${char}" == '{' ]]; then
      sizebracketsopen=TRUE
    elif [[ "${char}" == '}' ]]; then
      sizebracketsopen=FALSE
    elif [[ "${sizebracketsopen}" == TRUE ]] && (( depth == 0 )); then
      sublayoutsizings[${#sublayoutsizings[@]} - 1]+="${char},"
    fi

    if [[ "${char}" == ']' ]]; then
      (( depth -= 1 )) || true
    fi

    if (( depth > 0 )); then
      sublayouts[${#sublayouts[@]} - 1]+="${char}"

      if [[ "${char}" =~ ^[0-9]+$ && "${sizebracketsopen}" == FALSE ]]; then
        (( sublayoutpanecounts[${#sublayoutpanecounts[@]} - 1] += char )) || true
      fi
    fi

    if [[ "${char}" == '[' ]]; then
      if (( depth == 0 )); then
        sublayouts+=( "" )
        sublayoutpanecounts+=( 0 )
        sublayoutsizings+=( "" )
      fi
      (( depth += 1 )) || true
    fi

    if [[ "${char}" =~ ^[0-9]+$ && "${sizebracketsopen}" == FALSE ]] && (( depth == 0 )); then
      sublayout=$( printf '%0.s1' $( seq 1 "${char}" ) ) # "111..1" str len == char
      sublayouts+=( "${sublayout}" )
      sublayoutpanecounts+=( "${char}" )
      sublayoutsizings+=( "" )
    fi
  done

  numsublayouts="${#sublayouts[@]}"

  # construct initial set of panes
  initialcmds=()
  initialcmdidx=0

  for (( idx = 0; idx < numsublayouts; idx++ )); do
    sublayoutpanecount="${sublayoutpanecounts[${idx}]}"
    initialcmds+=( "${cmds[${initialcmdidx}]-}" )
    (( initialcmdidx += sublayoutpanecount )) || true
  done
  split1d "${direction}" "${numsublayouts}" "${sizing}" "${initialcmds[@]}"

  # select first pane
  selectpane "${direction}" "UL" $(( numsublayouts - 1 ))

  # split each pane as specified by layout
  initialcmdidx=0
  for (( idx = 0; idx < numsublayouts; idx++ )); do
    sublayout="${sublayouts[${idx}]}"
    sublayoutpanecount="${sublayoutpanecounts[${idx}]}"
    sublayoutsizing="${sublayoutsizings[${idx}]}"

    if (( idx > 0 )); then
      selectpane "${direction}" "DR" 1
    fi

    [[ "${direction}" == 'v' ]] && flag='h' || flag='v'
    subcmds=( "${cmds[@]:${initialcmdidx}:${sublayoutpanecount}}" )

    # if layout contains only columns of 1, we can split 1-dimensional
    if [[ "${sublayout}" =~ ^1+$ ]]; then
      split1d "${flag}" "${sublayoutpanecount}" "${sublayoutsizing}" "${subcmds[@]-}"
    else
      split2d "${flag}" "${sublayout}" "${sublayoutsizing}" "${subcmds[@]-}"
    fi

    (( initialcmdidx += sublayoutpanecount )) || true
  done
}

function main () {
  local argdetached argfocus arghelp argkill arglayout arglayoutoriginal argcmds
  local argnpm argprint argreattach argsession argshellless argtranspose argversion

  local tmuxargs cmd idx flag output pattern version tmuxversion usage help
  local layoutsize toplevelsizing parentlayout

  # Construct and execute a tmux command that runs a set of commands inside a layout.
  # Params:
  #   $@ args [array<any>] arguments passed to script

  tmuxversion="$( tmux -V )"
  if [[ "${tmuxversion}" =~ ([0-9]+(\.[0-9]+)?) ]]; then
    tmuxversion="${BASH_REMATCH[0]}"
  elif [[ -z "${TMEX_SUPPRESS_WARNING_PCT_FLAGS:-}" ]]; then
    echo "Warning: current tmux version could not be determined from"
    echo "  tmux -V  >>>  \"${tmuxversion}\""
    echo "This can result in incorrect pane-splitting behavior since tmux has made"
    echo "backwards-incompatible changes to flags of the split-window command."
    echo "Please ensure your installation of tmux produces a semver string within"
    echo "the output of 'tmux -V', or add 'export TMEX_SUPPRESS_WARNING_PCT_FLAGS=1'"
    echo "to your shell rc file to hide this warning."
    echo "See https://github.com/tmux/tmux/blob/master/CHANGES#L663-L665 for details."
    echo
  fi

  version="$( head -n 3 < "$0" | tail -1 )"
  version="${version#\# }"  # remove "# " prefix
  usage='Usage:

tmex <session-name> -nt 1224 "cmd a" "cmd b" "cmd c" ... etc.
                     |     |              |
           options --+     +-- layout     +-- shell commands

tmex <session-name>                - session name required unless --npm or --kill set; all other args optional
  [-h|--help]
  [-v|--version]
  [[-l|--layout] <0-9,/,[,],{,}>]  -l, --layout      layout string, each digit represents number of panes in column
  [[-f|--focus] <0-9>]             -f, --focus       tmux pane to select by index, must be an integer
  [-t|--transpose]                 -t, --transpose   build layout in left-to-right orientation instead of top-to-bottom
  [-n|--npm]                       -n, --npm         if set, prefix each command with "npm run" for package.json scripts
  [-p|--print]                     -p, --print       emit command as string of tmux args instead of invoking tmux directly
  [-d|--detached]                  -d, --detached    invoke tmux with -d (detached session); useful for piping data to tmex
  [-r|--reattach]                  -r, --reattach    if tmux session already exists, re-attach to it instead of replacing it
  [-s|--shellless]                 -s, --shellless   if set, invoke commands directly with tmux instead of running inside shell
  [-k|--kill]                      -k, --kill        kill the current or specified tmux session (all other arguments ignored)
  ["shell command 1"]
  ["shell command 2"]              - shell commands that will be executed in each pane
  ...                               number of shell commands N must not exceed sum of layout
  ["shell command N"]
'
  # shellcheck disable=SC2016
  help='-l, --layout
  If no layout is provided, a default will be generated to match the number of commands provided.
  Otherwise, layout must be a string of digits 0-9, and [ ] { } chars. Each digit divides a column into a number of panes, e.g.
    $ tmex -n --layout=1224
  This layout produces 1 pane in the first column, 2 panes in the 2nd and 3rd columns, and 4 panes in the 4th column.
  [ ] and { } delineate sub-layouts and custom sizing. e.g.
    $ tmex -n --layout=1[2{34}5]6
  The layout contains the sub-layout 2{34}5 which will be constructed within the second column.
  The sub-layout specifies 3/4 sizing ratio for the 2 panes in its first row.

-n, --npm
  If set, each command is prefixed with "npm run " for tersely chaining npm script commands, and env var npm_package_name
  will be used as the session name if it is ommitted (npm_package_name refers to the `name` field provided in package.json).
    $ tmex -n build test
    > tmux new-session -s mypackagename "npm run build" ; split-window -h "npm run test"

-d, --detached
  Invoke tmux with -d flag, starting session in "detached" mode. Useful for building a dynamic list of commands and piping to tmux
  via xargs; tmux will not have a valid psuedo-tty and will error unless -d is set. Outputs session name for attachment, e.g:
    $ tmux attach-session -t "$( echo "a b c" | xargs tmex -nd --layout 21 )"

For more information, see https://github.com/evnp/tmex
'

  # Parse args into vars:
  argdetached=FALSE  # optional - if TRUE, invoke tmux with -d flag (detached session)
  argfocus=''        # optional - tmux pane to select by index
  arghelp=FALSE      # optional - if TRUE, display usage message and exit
  arglayout=''       # optional - string of digits defining a custom layout
  argnpm=FALSE       # optional - if TRUE, prefix each command with "npm run" for package.json scripts
  argprint=FALSE     # optional - if TRUE, print final tmux command to console instead of executing it
  argreattach=FALSE  # optional - if TRUE, re-attach to existing tmux session isntead of replacing it
  argsession=''      # required - session name
  argshellless=FALSE # optional - if TRUE, execute commands standalone instead of in a shell
  argtranspose=FALSE # optional - if TRUE, layout in left-to-right instead of top-to-bottom orientation
  argversion=FALSE   # optional - if TRUE, display version and exit
  argcmds=''         # optional - list of commands to be executed in resulting panes

  processargs "$@"

  if [[ "${arghelp}" == TRUE ]]; then
    echo "${version}"
    echo ""
    echo "${usage}"
    echo "${help}"
    exit 0
  fi

  if [[ "${argversion}" == TRUE ]]; then
    echo "${version}"
    exit 0
  fi

  # if -k/--kill specified tmux session and exit:
  if [[ "${argkill}" == TRUE ]]; then
    tmuxargs=("kill-session" "-t" "${argsession}")
    if [[ "${argprint}" == TRUE ]]; then
      echo "${tmuxargs[@]}"
    else
      tmux "${tmuxargs[@]}"
    fi
    exit 0
  fi

  # if npm option is set, prefix commands "npm run ..."
  if [[ "${argnpm}" == TRUE ]]; then
    for (( idx = 0; idx < ${#argcmds[@]}; idx++ )); do
      if ! [[ "${argcmds[idx]}" == 'npm '* ]]; then
        argcmds[idx]="npm run ${argcmds[idx]}"
      fi
    done
  fi

  # begin to construct tmux arguments
  tmuxargs=()

  # if we're already in a tmux pane, further split the pane rather than nesting tmux sessions
  paneid="${TMUX_PANE-}"
  if [[ -n "${paneid}" ]]; then
    # ensure we're not in "shell-less" mode; this would fail to run the 1st command in the 1st
    # pane since the pane would die after executing the nested tmex command
    if [[ "${argshellless}" == TRUE ]]; then
      echo "Error: --shellless mode cannot be used when nesting tmex commands"
      exit 1
    fi
    tmuxargs+=( 'select-window' '-t' "${paneid}" ';' 'select-pane' '-t' "${paneid}" )

  # otherwise start a new session
  else
    tmuxargs+=( 'new-session' '-s' "${argsession}" )

    # if running in "detached" mode, add -d flag
    if [[ "${argdetached}" == TRUE ]]; then
      tmuxargs+=( '-d' )
    fi
  fi

  executecmd "${argcmds[0]-}"

  # if layout is not specified, generate a default
  if [[ -z "${arglayout}" ]]; then
    generatelayout "${#argcmds[@]}"
  else
    arglayoutoriginal="${arglayout}"

    # --- Grid Sub-Layouts --- #
    # for each set of digits within layout followed by {+}
    # replace with a default grid sub-layout with size matching digits:
    pattern="([0-9]+)\{\+\}"
    shopt -s nocasematch
    while [[ "${arglayout}" =~ ${pattern} ]]; do
      layoutsize="${BASH_REMATCH[1]}"
      parentlayout="${arglayout}"
      generatelayout "${layoutsize}"
      # wrap every pane count of new sub-layout within its own set of [[ ]] brackets,
      # so that slashes in adjacent sections of parent layout don't trigger multi-digit
      # counting logic within the new sub-layout:
      arglayout="$( sed -E 's/([0-9])/[[\1]]/g' <<< "${arglayout}" )"
      arglayout="${parentlayout/${layoutsize}\{+\}/${arglayout}}"
    done
    shopt -u nocasematch
    # if layout _starts_ with {+} exit with error
    if [[ "${arglayout}" == '{+}'* ]]; then
      echo ""
      echo "Invalid input: --layout=${arglayoutoriginal} cannot start with {+} clause"
      echo ""
      echo "${usage}"
      exit 1
    fi

    # --- Top Level Sizing --- #
    # if layout starts with { } bracket sizing, automatically wrap the whole thing
    # in a sublayout and transpose it, so that top-level sizing is applied
    pattern="^(\{[0-9,]+\})"
    if [[ "${arglayout}" =~ ${pattern} ]]; then
      toplevelsizing="${BASH_REMATCH[1]}"
      arglayout="[${arglayout/${toplevelsizing}/}]${toplevelsizing}"
      [[ "${argtranspose}" == TRUE ]] && argtranspose=FALSE || argtranspose=TRUE
    fi
  fi

  # ensure layout is large enough to contain commands provided
  validatelayout "${#argcmds[@]}"

  # append layout commands onto tmuxargs
  [[ "${argtranspose}" == TRUE ]] && flag='v' || flag='h'
  split2d "${flag}" "${arglayout}" '' "${argcmds[@]-}"

  # select a pane if focus arg was provided
  if [[ -n "${argfocus}" ]]; then
    tmuxargs+=( ';' 'select-pane' "-t${argfocus}" )
  fi

  # if running shell-less, command exit will kill tmux pane which makes troubleshooting hard
  # set remain-on-exit on - more of a sane default since user will see when a command failed
  if [[ "${argshellless}" == TRUE ]]; then
    tmuxargs+=( ';' 'set-window-option' 'remain-on-exit' 'on' ';' )
  fi

  if [[ "${argprint}" == TRUE ]]; then
    output=""
    for (( idx = 0; idx < ${#tmuxargs[@]}; idx++ )); do
      if [[ "${tmuxargs[idx]}" == *' '* ]]; then
        output+="\"${tmuxargs[idx]}\" "
      else
        output+="${tmuxargs[idx]} "
      fi
    done
    echo "${output}"
  else
    # either attach to an existing session or kill it based on specified behavior
    if [[ -z "${paneid}" ]]; then # avoid doing this if we're already in tmux session
      if tmux has-session -t "${argsession}" 2>/dev/null; then
        if [[ "${argreattach}" == TRUE ]]; then
          tmux attach-session -t "${argsession}"
          exit 0
        else
          tmux kill-session -t "${argsession}"
        fi
      fi
    fi

    # execute constructed tmux command
    tmux "${tmuxargs[@]}"

    # ouput session name for later attachment, setting options, etc.
    echo "${argsession}"
  fi
}

main "$@"
